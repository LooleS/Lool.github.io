---
title: LeetCode中有效的数独题解
description: LeetCode中有效的数独题解-java
tags:
  - LeetCode
  - 算法
categories: LeetCode
abbrlink: 43be1d83
date: 2020-12-09 20:02:00
---

#  LeetCode中有效的数独题解-java

## 题目

#### [36. 有效的数独](https://leetcode-cn.com/problems/valid-sudoku/)

难度中等449收藏分享切换为英文接收动态反馈

判断一个 9x9 的数独是否有效。只需要**根据以下规则**，验证已经填入的数字是否有效即可。

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Sudoku-by-L2G-20050714.svg/250px-Sudoku-by-L2G-20050714.svg.png)

上图是一个部分填充的有效的数独。

数独部分空格内已填入了数字，空白格用 `'.'` 表示。

**示例 1:**

```
输入:
[
  ["5","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: true
```

**示例 2:**

```
输入:
[
  ["8","3",".",".","7",".",".",".","."],
  ["6",".",".","1","9","5",".",".","."],
  [".","9","8",".",".",".",".","6","."],
  ["8",".",".",".","6",".",".",".","3"],
  ["4",".",".","8",".","3",".",".","1"],
  ["7",".",".",".","2",".",".",".","6"],
  [".","6",".",".",".",".","2","8","."],
  [".",".",".","4","1","9",".",".","5"],
  [".",".",".",".","8",".",".","7","9"]
]
输出: false
解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。
     但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。
```

**说明:**

- 一个有效的数独（部分已被填充）不一定是可解的。
- 只需要根据以上规则，验证已经填入的数字是否有效即可。
- 给定数独序列只包含数字 `1-9` 和字符 `'.'` 。
- 给定数独永远是 `9x9` 形式的。

## 题解

### 方法一：

#### 思路

要求行，列，方块中不能有重复的数字，采用Boolean二维数组来保存是否出现此数字，新建三个Boolean二维数组row，col,block,默认值为false，表示全未出现过，然后遍历二维数组board，当此值不等于‘.'时，首先取出此下标的值，并计算对应的下标，然后根据遍历的行号列好计算对应的块号，然后判断是否在row，col,block数组对应下标的值是否为true（为true表示之前已出现过此数字，重复），如果有一个及以上为true，则返回false，如果全为false，则将row，col,block数组对应的下标的值设置为true，代表此数字已出现，下次不能再出现，若遍历结束，仍未发现有重复的数字（满足要求），则返回true



#### 代码实现

```java
class Solution {
    public boolean isValidSudoku(char[][] board) {
     
        // 记录某行中某位数字是否已出现
        boolean[][] row = new boolean[9][9];
        // 记录某列中某位数字是否已出现
        boolean[][] col = new boolean[9][9];
        // 记录某3*3宫格内某位数字是否已出现
        boolean[][] block = new boolean[9][9];

        // 遍历board二维数组
        for(int i = 0; i < 9; i++){
            for(int j = 0; j < 9; j++){
                // 当board[i][j] 不等于‘.’ 时，计算此时值对应的下标与此时值所在的块号坐标
                if(board[i][j] != '.'){
                    // 纵坐标长度为9，分别对应1-9个数字，其下标对应为数字字符-1字符
                    int num = board[i][j] -'1';
                    // 计算对应块号的下标
                    int blockIndex = i /3 * 3 + j / 3;
                    // 判断是否满足行，列与3*3宫格中是否出现，
                    if(row[i][num] || col[j][num] || block[blockIndex][num]){
                        return false;
                    }else{
                        // 若未出现，不返回false，并将行，列与此块中对应的下标值设为true
                        row[i][num] = true;
                        col[j][num] = true;
                        block[blockIndex][num] = true;
                    }
                }
            }
        }
        return true;
    }
}
```



#### 复杂度分析

- 时间复杂度：O(1)，因为board为9*9数组，n为常数，所以时间复杂度为O(1)
- 空间复杂度：O(1)，使用了额外固定大小的Boolean二维数组，空间复杂度为O(1)

#### 提交详情

![image-20201209201115263](https://gitee.com/happyzm/images/raw/master/image-20201209201115263.png)



### 方法二：

#### 思路



#### 代码实现



#### 复杂度分析



#### 提交详情